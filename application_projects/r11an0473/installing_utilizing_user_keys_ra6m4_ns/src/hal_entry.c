/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : hal_entry function is called by main when no RTOS is used
 **********************************************************************************************************************/
/***********************************************************************************************************************
 * DISCLAIMER
 * This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
 * other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
 * applicable laws, including copyright laws.
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
 * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
 * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
 * SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
 * this software. By using this software, you agree to the additional terms and conditions found by accessing the
 * following link:
 * http://www.renesas.com/disclaimer
 *
 * Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
 ***********************************************************************************************************************/
#include "hal_data.h"
#include "aes_functions.h"
#include "app_definitions.h"
#include "common_utils.h"


FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* structures to share with the Non-secure region */
non_secure_encryption_args_t non_secure_enc_args;
non_secure_decryption_args_t non_secure_dec_args;


enum
    {
        block_size = 16, ///< NOLINT(readability-uppercase-literal-suffix)
        key_bits   = 256,
        input_size = 48,
    };
static uint8_t key_id = 1;

/* NIST vector */
/* 6282b8c05c5c1530b97d4816ca434762 */
static const uint8_t NIST_AES256_CBC_plaintext[] =
{
    0x8d, 0x3a, 0xa1, 0x96, 0xec, 0x3d, 0x7c, 0x9b, 0x5b, 0xb1, 0x22, 0xe7, 0xfe, 0x77, 0xfb, 0x12,
    0x95, 0xa6, 0xda, 0x75, 0xab, 0xe5, 0xd3, 0xa5, 0x10, 0x19, 0x4d, 0x3a, 0x8a, 0x41, 0x57, 0xd5,
    0xc8, 0x9d, 0x40, 0x61, 0x97, 0x16, 0x61, 0x98, 0x59, 0xda, 0x3e, 0xc9, 0xb2, 0x47, 0xce, 0xd9
};
/* NIST vector */
/* 6acc04142e100a65f51b97adf5172c41 */
static uint8_t NIST_AES256_CBC_ciphertext[] =
{
    0x60, 0x8e, 0x82, 0xc7, 0xab, 0x04, 0x00, 0x7a, 0xdb, 0x22, 0xe3, 0x89, 0xa4, 0x47, 0x97, 0xfe,
    0xd7, 0xde, 0x09, 0x0c, 0x8c, 0x03, 0xca, 0x8a, 0x2c, 0x5a, 0xcd, 0x9e, 0x84, 0xdf, 0x37, 0xfb,
    0xc5, 0x8c, 0xe8, 0xed, 0xb2, 0x93, 0xe9, 0x8f, 0x02, 0xb6, 0x40, 0xd6, 0xd1, 0xd7, 0x24, 0x64
};

/* encryption and decryption result */
static size_t               encrypted_length  = 0;
static size_t               decrypted_length  = 0;
static uint8_t              encrypted_data[input_size] = {0};
static uint8_t              decrypted_data[input_size] = {0};

static bool status = true;  /*track secure service execution pass/fail status */

static void print_main_menu(void);
static void print_main_menu(void)
{

    APP_PRINT(MENUOPTION_MENU);

    /* Menu for User Selection */
    APP_PRINT(MENUOPTION1);
    APP_PRINT(MENUOPTION2);
    APP_PRINT(MENUOPTION3);
    APP_PRINT(MENUOPTION4);
}


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void) {
	/* TODO: add your own code here */
    init_lfs();
        print_main_menu();
        uint8_t readBuff[BUFF_SIZE] =  { RESET_VALUE };
        while(true)
        {
            if (APP_CHECK_DATA)
            {
                uint32_t rByte = APP_READ(readBuff);
                /* function returns the converted integral number as an int value.*/
                int32_t inputRead = atoi((char *)readBuff);

                if (rByte > RESET_VALUE)
                {
                    switch (inputRead)
                    {
                        case CREATE_AES_KEY_INSTALL_PLAINTEXT:
                       {
                           APP_PRINT(MENUEVENT1);
                           status = wrap_install_aes_key(key_id);
                           if (true == status)
                           {
                               APP_PRINT(AES_KEY_CREATION_SUCCESSFUL);
                           }
                           else
                           {
                               APP_PRINT(AES_KEY_CREATION_FAILED);
                           }
                           key_id ++;
                           if(key_id == 20)
                           {
                               APP_PRINT(NEED_CLEANING);
                           }
                       }
                       break;
                        case ENCRYPT_USER_DATA:
                        {
                            APP_PRINT(MENUEVENT2);
                            non_secure_enc_args.c_input = NIST_AES256_CBC_plaintext;
                            non_secure_enc_args.input_size = input_size;
                            non_secure_enc_args.output = encrypted_data;
                            non_secure_enc_args.output_size = sizeof(encrypted_data);
                            non_secure_enc_args.output_len = &encrypted_length;
                            status = encryption_operation(&non_secure_enc_args);
                            if(true == status)
                            {

                                if (0 != memcmp(NIST_AES256_CBC_ciphertext, encrypted_data, sizeof(NIST_AES256_CBC_ciphertext)))
                                {
                                    /* Comparing encrypted with NIST cipher data failed */
                                    APP_PRINT(ENCRYPTION_FAILED);
                                }
                                else
                                {
                                   APP_PRINT(ENCRYPTION_SUCCESSFUL);
                                }
                            }
                            else
                            {
                                APP_PRINT(ENCRYPTION_FAILED);
                            }
                        }
                        break;
                        case DECRYPT_USER_DATA:
                        {
                            APP_PRINT(MENUEVENT3);
                            non_secure_dec_args.c_input = encrypted_data;
                            non_secure_dec_args.input_size2 = encrypted_length;
                            non_secure_dec_args.output = decrypted_data;
                            non_secure_dec_args.output_size = sizeof(decrypted_data);
                            non_secure_dec_args.output_len = &decrypted_length;

                            status = decryption_operation(&non_secure_dec_args);

                            if(true == status)
                            {
                                if (0 != memcmp(NIST_AES256_CBC_plaintext, decrypted_data, sizeof(NIST_AES256_CBC_plaintext)))
                                {
                                    /* Comparing the input data with decrypted data failed */
                                    APP_PRINT(DECRYPTION_FAILED);
                                }
                                else
                                {

                                    APP_PRINT(DECRYPTION_SUCCESSFUL);
                                }
                            }
                            else
                            {
                                APP_PRINT(DECRYPTION_FAILED);
                            }
                        }
                        break;
                        case DESTROY_AES_KEY:
                        {
                            APP_PRINT(MENUEVENT5);
                            status = destroy_the_key();
                            if (true == status)
                            {
                                APP_PRINT(AES_KEY_DESTROYED);
                            }
                            else
                            {
                                APP_PRINT(AES_KEY_DESTROY_FAILED);
                            }

                        }
                        break;
                        default:
                        {
                            APP_PRINT(NOT_SUPPORTED);
                            /* Menu for User Selection */
                            print_main_menu();

                        }
                        break;
                    }
                }
            }

        }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event) {
	if (BSP_WARM_START_RESET == event) {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
	}

	if (BSP_WARM_START_POST_C == event) {
		/* C runtime environment and system clocks are setup. */

		/* Configure pins. */
		R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
	}
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
