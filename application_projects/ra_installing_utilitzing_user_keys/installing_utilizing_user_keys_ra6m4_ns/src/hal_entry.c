/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : hal_entry function is called by main when no RTOS is used
 **********************************************************************************************************************/
/***********************************************************************************************************************
 * DISCLAIMER
 * This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
 * other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
 * applicable laws, including copyright laws.
 * THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
 * THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
 * EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
 * SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
 * SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
 * this software. By using this software, you agree to the additional terms and conditions found by accessing the
 * following link:
 * http://www.renesas.com/disclaimer
 *
 * Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
 ***********************************************************************************************************************/
#include "hal_data.h"
#include "aes_functions.h"
#include "app_definitions.h"
#include "common_utils.h"


FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* structures to share with the Non-secure region */
non_secure_encryption_args_t non_secure_enc_args;
non_secure_decryption_args_t non_secure_dec_args;
aes_creation_args_t aes_creation_args;

/* user defined AES operation information */
enum
    {
        block_size = 16, ///< NOLINT(readability-uppercase-literal-suffix)
        key_bits   = 256,
        input_size = 100,
    };

static uint8_t key_id = 1;
static uint8_t              input[input_size] = "this is my non-secure data to be encrypted";

/* encryption and decryption result */
static size_t               encrypted_length  = 0;
static size_t               decrypted_length  = 0;
static uint8_t              encrypted_data[input_size + block_size] = {0};
static uint8_t              decrypted_data[input_size + block_size] = {0};

static bool status = true;  /*track secure service execution pass/fail status */

static bool compare_prior_to_enc_and_after_dec(void);
static bool compare_prior_to_enc_and_after_dec(void)
{
    if (0 != memcmp(input, decrypted_data, sizeof(input)))
    {
        /* Comparing the input data with decrypted data failed */
        return false;
    }
    else
    {
        return true;
    }
}
static void print_main_menu(void);
static void print_main_menu(void)
{

    APP_PRINT(MENUOPTION_MENU);

    /* Menu for User Selection */
    APP_PRINT(MENUOPTION1);
    APP_PRINT(MENUOPTION2);
    APP_PRINT(MENUOPTION3);
    APP_PRINT(MENUOPTION4);
    APP_PRINT(MENUOPTION5);
}


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void) {
	/* TODO: add your own code here */
    init_lfs();
        print_main_menu();
        uint8_t readBuff[BUFF_SIZE] =  { RESET_VALUE };
        while(true)
        {
            if (APP_CHECK_DATA)
            {
                uint32_t rByte = APP_READ(readBuff);
                /* function returns the converted integral number as an int value.*/
                int32_t inputRead = atoi((char *)readBuff);

                if (rByte > RESET_VALUE)
                {
                    switch (inputRead)
                    {
                        case CREATE_AES_KEY_INSTALL_PLAINTEXT:
                       {
                           APP_PRINT(MENUEVENT1);
                           aes_creation_args.key_bit = key_bits;
                           aes_creation_args.key_id = key_id;
                           status = create_aes_key(&aes_creation_args);
                           if (true == status)
                           {
                               APP_PRINT(AES_KEY_CREATION_SUCCESSFUL);
                           }
                           else
                           {
                               APP_PRINT(AES_KEY_CREATION_FAILED);
                           }
                           key_id ++;
                           if(key_id == 20)
                           {
                               APP_PRINT(NEED_CLEANING);
                           }
                       }
                       break;
                        case ENCRYPT_USER_DATA:
                        {
                            APP_PRINT(MENUEVENT2);
                            non_secure_enc_args.c_input = input;
                            non_secure_enc_args.input_size = input_size;
                            non_secure_enc_args.output = encrypted_data;
                            non_secure_enc_args.output_size = sizeof(encrypted_data);
                            non_secure_enc_args.output_len = &encrypted_length;
                            status = encryption_operation(&non_secure_enc_args);
                            if (true == status)
                            {
                                APP_PRINT(ENCRYPTION_SUCCESSFUL);
                            }
                            else
                            {
                                APP_PRINT(ENCRYPTION_FAILED);
                            }
                        }
                        break;
                        case DECRYPT_USER_DATA:
                        {
                            APP_PRINT(MENUEVENT3);
                            non_secure_dec_args.c_input = encrypted_data;
                            non_secure_dec_args.input_size2 = encrypted_length;
                            non_secure_dec_args.output = decrypted_data;
                            non_secure_dec_args.output_size = sizeof(decrypted_data);
                            non_secure_dec_args.output_len = &decrypted_length;

                            status = decryption_operation(&non_secure_dec_args);

                            if (true == status)
                            {
                                APP_PRINT(DECRYPTION_SUCCESSFUL);
                            }
                            else
                            {
                                APP_PRINT(DECRYPTION_FAILED);
                            }
                        }
                        break;
                        case COMPARISON:
                        {
                            APP_PRINT(MENUEVENT4);
                            status = compare_prior_to_enc_and_after_dec();
                            if (true == status)
                            {
                                APP_PRINT(COMPARISON_MATCHED);
                            }
                            else
                            {
                                APP_PRINT(COMPARISON_NOT_MATCHED);
                            }
                        }
                        break;
                        case DESTROY_AES_KEY:
                        {
                            APP_PRINT(MENUEVENT5);
                            status = destroy_the_key();
                            if (true == status)
                            {
                                APP_PRINT(AES_KEY_DESTROYED);
                            }
                            else
                            {
                                APP_PRINT(AES_KEY_DESTROY_FAILED);
                            }

                        }
                        break;
                        default:
                        {
                            APP_PRINT(NOT_SUPPORTED);
                            /* Menu for User Selection */
                            print_main_menu();

                        }
                        break;
                    }
                }
            }

        }

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event) {
	if (BSP_WARM_START_RESET == event) {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
	}

	if (BSP_WARM_START_POST_C == event) {
		/* C runtime environment and system clocks are setup. */

		/* Configure pins. */
		R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
	}
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
